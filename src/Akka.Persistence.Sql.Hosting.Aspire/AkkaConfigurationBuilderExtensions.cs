using Akka.Actor;
using Akka.Hosting;
using Akka.Persistence.Hosting;
using Akka.Persistence.Sql.Config;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace Akka.Persistence.Sql.Hosting.Aspire;

public static class AkkaConfigurationBuilderExtensions
{
    /// <summary>
    ///     Adds Akka.Persistence.Sql support to this <see cref="ActorSystem" /> with optional support
    ///     for health checks on both journal and snapshot store.
    /// </summary>
    /// <param name="builder">
    ///     The builder instance being configured.
    /// </param>
    /// <param name="provider">
    /// </param>
    /// <param name="connectionName">
    /// </param>
    /// <param name="providerName">
    ///     A string constant defining the database type to connect to, valid values are defined inside
    ///     <see cref="LinqToDB.ProviderName" /> static class.
    ///     Refer to the Members of <see cref="LinqToDB.ProviderName" /> for included providers.
    /// </param>
    /// <param name="mode">
    ///     <para>
    ///         Determines which settings should be added by this method call.
    ///     </para>
    ///     <i>Default</i>: <see cref="PersistenceMode.Both" />
    /// </param>
    /// <param name="schemaName">
    ///     <para>
    ///         SQL schema name to table corresponding with persistent journal.
    ///     </para>
    ///     <b>Default</b>: <c>null</c>
    /// </param>
    /// <param name="journalBuilder">
    ///     <para>
    ///         An <see cref="Action{T}" /> used to configure an <see cref="AkkaPersistenceJournalBuilder" /> instance.
    ///     </para>
    ///     <i>Default</i>: <c>null</c>
    /// </param>
    /// <param name="snapshotBuilder">
    ///     <para>
    ///         An <see cref="Action{T}" /> used to configure an <see cref="AkkaPersistenceSnapshotBuilder" /> instance.
    ///     </para>
    ///     <i>Default</i>: <c>null</c>
    /// </param>
    /// <param name="autoInitialize">
    ///     <para>
    ///         Should the SQL store table be initialized automatically.
    ///     </para>
    ///     <i>Default</i>: <c>true</c>
    /// </param>
    /// <param name="pluginIdentifier">
    ///     <para>
    ///         The configuration identifier for the plugins
    ///     </para>
    ///     <i>Default</i>: <c>"sql"</c>
    /// </param>
    /// <param name="isDefaultPlugin">
    ///     <para>
    ///         A <c>bool</c> flag to set the plugin as the default persistence plugin for the <see cref="ActorSystem" />
    ///     </para>
    ///     <b>Default</b>: <c>true</c>
    /// </param>
    /// <param name="databaseMapping">
    ///     <para>
    ///         The <see cref="DatabaseMapping" /> to modify database table column mapping for this journal.
    ///     </para>
    ///     <b>NOTE</b>: This is used primarily for backward compatibility,
    ///     you leave this empty for greenfield projects.
    /// </param>
    /// <param name="tagStorageMode">
    ///     <para>
    ///         Describe how tags are being stored inside the database. Setting this to
    ///         <see cref="TagMode.Csv" /> will store the tags as a comma delimited value
    ///         in a column named <c>tags</c> inside the event journal. Setting this to
    ///         <see cref="TagMode.TagTable" /> will store the tags inside a separate
    ///         tag table instead.
    ///     </para>
    ///     <b>NOTE</b>: This is used primarily for backward compatibility,
    ///     you leave this empty for greenfield projects.
    /// </param>
    /// <param name="deleteCompatibilityMode">
    ///     <para>
    ///         If true, journal_metadata is created and used for deletes
    ///         and max sequence number queries.
    ///     </para>
    ///     <b>NOTE</b>: This is used primarily for backward compatibility,
    ///     you leave this empty for greenfield projects.
    /// </param>
    /// <param name="useWriterUuidColumn">
    ///     <para>
    ///         A flag to indicate if the writer_uuid column should be generated and be populated in run-time.
    ///     </para>
    ///     <b>Notes:</b>
    ///     <list type="number">
    ///         <item>
    ///             The column will only be generated if auto-initialize is set to true.
    ///         </item>
    ///         <item>
    ///             This feature is Akka.Persistence.Sql specific, setting this to true will break
    ///             backward compatibility with databases generated by other Akka.Persistence plugins.
    ///         </item>
    ///         <item>
    ///             <para>
    ///                 To make this feature work with legacy plugins, you will have to alter the old
    ///                 journal table:
    ///             </para>
    ///             <c>ALTER TABLE [journal_table_name] ADD [writer_uuid_column_name] VARCHAR(128);</c>
    ///         </item>
    ///         <item>
    ///             If set to true, the code will not check for backward compatibility. It will expect
    ///             that the `writer-uuid` column to be present inside the journal table.
    ///         </item>
    ///     </list>
    /// </param>
    /// <param name="maxConcurrentQueries">
    ///     Determines how many queries are allowed to run in parallel at any given time
    /// </param>
    /// <returns>
    ///     The same <see cref="AkkaConfigurationBuilder" /> instance originally passed in.
    /// </returns>
    /// <exception cref="ArgumentOutOfRangeException">
    ///     Thrown when <paramref name="journalBuilder" /> is set and <paramref name="mode" /> is set to
    ///     <see cref="PersistenceMode.SnapshotStore" />
    /// </exception>
    /// <exception cref="ArgumentNullException">
    ///     Thrown when <paramref name="connectionString"/> or <paramref name="providerName"/> is null
    ///     or whitespace
    /// </exception>
    /// <example>
    /// <code>
    /// builder.WithSqlPersistence(
    ///     connectionString: "...",
    ///     providerName: ProviderName.SQLite,
    ///     journalBuilder: journal => journal
    ///         .AddEventAdapter&lt;MyAdapter&gt;("adapter", new[] { typeof(MyEvent) })
    ///         .WithHealthCheck(HealthStatus.Degraded),
    ///     snapshotBuilder: snapshot => snapshot
    ///         .WithHealthCheck(HealthStatus.Degraded));
    /// </code>
    /// </example>
    public static AkkaConfigurationBuilder WithSqlPersistence(
        this AkkaConfigurationBuilder builder,
        IServiceProvider provider,
        string connectionName,
        string providerName,
        PersistenceMode mode = PersistenceMode.Both,
        string? schemaName = null,
        Action<AkkaPersistenceJournalBuilder>? journalBuilder = null,
        Action<AkkaPersistenceSnapshotBuilder>? snapshotBuilder = null,
        bool autoInitialize = true,
        string pluginIdentifier = "sql",
        bool isDefaultPlugin = true,
        DatabaseMapping? databaseMapping = null,
        TagMode? tagStorageMode = null,
        bool? deleteCompatibilityMode = null,
        bool? useWriterUuidColumn = null,
        int? maxConcurrentQueries = null)
    {
        if (mode == PersistenceMode.SnapshotStore && journalBuilder is not null)
        {
            throw new Exception(
                $"{nameof(journalBuilder)} can only be set when {nameof(mode)} is set to either {PersistenceMode.Both} or {PersistenceMode.Journal}");
        }

        if (mode == PersistenceMode.Journal && snapshotBuilder is not null)
        {
            throw new Exception(
                $"{nameof(snapshotBuilder)} can only be set when {nameof(mode)} is set to either {PersistenceMode.Both} or {PersistenceMode.SnapshotStore}");
        }
        
        var connectionString = provider.GetRequiredService<IConfiguration>().GetConnectionString(connectionName);

        if (string.IsNullOrWhiteSpace(connectionString))
        {
            throw new ArgumentNullException(nameof(connectionString), $"{nameof(connectionString)} can not be null");
        }

        if (string.IsNullOrWhiteSpace(providerName))
        {
            throw new ArgumentNullException(nameof(providerName), $"{nameof(providerName)} can not be null");
        }

        var journalOpt = new SqlJournalOptions(isDefaultPlugin, pluginIdentifier)
        {
            ConnectionString = connectionString,
            ProviderName = providerName,
            AutoInitialize = autoInitialize,
            TagStorageMode = tagStorageMode,
            DeleteCompatibilityMode = deleteCompatibilityMode,
            MaxConcurrentQueries = maxConcurrentQueries,
        };

        if (databaseMapping is not null)
            journalOpt.DatabaseOptions = databaseMapping.Value.JournalOption();

        if (schemaName is not null)
        {
            journalOpt.DatabaseOptions ??= JournalDatabaseOptions.Default;
            journalOpt.DatabaseOptions.SchemaName = schemaName;
        }

        if (useWriterUuidColumn is not null)
        {
            journalOpt.DatabaseOptions ??= JournalDatabaseOptions.Default;
            journalOpt.DatabaseOptions.JournalTable ??= JournalTableOptions.Default;
            journalOpt.DatabaseOptions.JournalTable.UseWriterUuidColumn = useWriterUuidColumn;
        }

        var snapshotOpt = new SqlSnapshotOptions(isDefaultPlugin, pluginIdentifier)
        {
            ConnectionString = connectionString,
            ProviderName = providerName,
            AutoInitialize = autoInitialize,
        };

        if (databaseMapping is not null)
            snapshotOpt.DatabaseOptions = databaseMapping.Value.SnapshotOption();

        if (schemaName is not null)
        {
            snapshotOpt.DatabaseOptions ??= new SnapshotDatabaseOptions(DatabaseMapping.Default);
            snapshotOpt.DatabaseOptions.SchemaName = schemaName;
        }

        return mode switch
        {
            PersistenceMode.Journal => builder.WithSqlPersistence(journalOpt, null, journalBuilder, snapshotBuilder),
            PersistenceMode.SnapshotStore => builder.WithSqlPersistence(null, snapshotOpt, journalBuilder,
                snapshotBuilder),
            PersistenceMode.Both =>
                builder.WithSqlPersistence(journalOpt, snapshotOpt, journalBuilder, snapshotBuilder),
            _ => throw new ArgumentOutOfRangeException(nameof(mode), mode, "Invalid PersistenceMode defined."),
        };
    }
}